<font face="微软雅黑" size = 3 >
<style>
body{
line-height:3em;
}
</style>
# 线程同步[](https://subingwen.cn/linux/thread-sync/)
## 1. 线程同步的概念
假设有4个线程A、B、C、D，当前一个线程A对内存中的共享资源进行访问的时候，其他线程B, C, D都不可以对这块内存进行操作，直到线程A对这块内存访问完毕为止，B，C，D中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，<font color =red>**我们可以了解到所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。**
</font>

![](https://subingwen.cn/linux/thread-sync/1568967847637.png)  
CPU对应寄存器、一级缓存、二级缓存、三级缓存是独占的，用于存储处理的数据和线程的状态信息，数据被CPU处理完成需要再次被写入到物理内存中，物理内存数据也可以通过文件IO操作写入到磁盘中。

在测试程序中两个线程共用全局变量number当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到CPU进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。

如果线程A执行这个过程期间就失去了CPU时间片，线程A被挂起了最新的数据没能更新到物理内存。线程B变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去CPU时间片挂起。线程A得到CPU时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程B已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。


### 1.2 同步方式
对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：**互斥锁、读写锁、条件变量、信号量**。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。  
找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的： 
 
- 在临界区代码的上边，添加加锁函数，对临界区加锁。
	* 哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。
- 在临界区代码的下边，添加解锁函数，对临界区解锁。
	* 出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。
- 通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。

## 2. 互斥锁

### 2.1 互斥锁函数
互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块, 被锁定的这个代码块, 所有的线程只能顺序执行(不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。

在Linux中互斥锁的类型为`pthread_mutex_t`，创建一个这种类型的变量就得到了一把互斥锁：  

	pthread_mutex_t  mutex;

在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。一般情况下，**每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。**
>Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回0，调用失败会返回相应的错误号：
	
	// 初始化互斥锁
	// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的
	int pthread_mutex_init(pthread_mutex_t *restrict mutex,
	           const pthread_mutexattr_t *restrict attr);
	// 释放互斥锁资源            
	int pthread_mutex_destroy(pthread_mutex_t *mutex);

参数: 
 
 * mutex: 互斥锁变量的地址
 * attr: 互斥锁的属性, 一般使用默认属性即可, 这个参数指定为NULL  

	// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中
	int pthread_mutex_lock(pthread_mutex_t *mutex);

这个函数被调用, 首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:  

 - 没有被锁定, 是打开的, 这个线程可以加锁成功, 这个这个锁中会记录是哪个线程加锁成功了  
 - 如果被锁定了, 其他线程加锁就失败了, 这些线程都会阻塞在这把锁上  
 - 当这把锁被解开之后, 这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞  
```
// 尝试加锁        
int pthread_mutex_trylock(pthread_mutex_t *mutex);  
```

调用这个函数对互斥锁变量加锁还是有两种情况:  

 - 如果这把锁没有被锁定是打开的，线程加锁成功  
 - 如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号
```
// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);  
```

 不是所有的线程都可以对互斥锁解锁，哪个线程加的锁, 哪个线程才能解锁成功。

### 2.2 互斥锁使用

我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。

## 3. 死锁
当多个线程访问共享资源, 需要加锁, 如果锁使用不当, 就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）  
造成死锁的场景有如下几种：
  
- 加锁之后忘记解锁。  
- 重复加锁, 造成死锁。  
    - 解锁前return,解锁的代码没有执行，导致下一次加锁为重复加锁。
    - 函数A的临界区中调用了函数B,导致函数B中的加锁代码为重复加锁。
- 在程序中有多个共享资源, 因此有很多把锁，随意加锁，导致相互被阻塞。
    - 两个线程A与B,两个共享资源X,Y。A锁定X,B锁定Y。在A的临界区内访问资源Y,在B的临界区访问X，这样就造成了拿不到对方的资源的锁，而又无法释放自己资源的锁，两个线程就一直阻塞在这里。
  
## 4. 读写锁
### 4.1 读写锁函数

读写锁是互斥锁的升级版, 在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。
读写锁是一把锁，锁的类型为pthread_rwlock_t，有了类型之后就可以创建一把读写锁了。

    pthread_rwlock_t rwlock;
之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：

- 锁的状态: 锁定/打开
- 锁定的是什么操作: 读操作/写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。
- 哪个线程将这把锁锁上了

读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源, 确定临界区，在临界区的开始位置加锁（读锁/写锁），临界区的结束位置解锁。

因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：
- 
- 使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，**读锁是共享的**。
- 使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，**写锁是独占的**。
- 使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为**写锁比读锁的优先级高**。

如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且**对共享资源读的操作越多，读写锁更有优势**。

>Linux提供的读写锁操作函数原型如下，如果函数调用成功返回0，失败返回对应的错误号  

    #include <pthread.h>
    pthread_rwlock_t rwlock;
    // 初始化读写锁
    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
               const pthread_rwlockattr_t *restrict attr);
    // 释放读写锁占用的系统资源
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
* 参数:
    * rwlock: 读写锁的地址，传出参数
    * attr: 读写锁属性，一般使用默认属性，指定为NULL
```
//在程序中对读写锁加读锁, 锁定的是读操作
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
```  
调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

```
// 在程序中对读写锁加写锁, 锁定的是写操作
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
```
调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。
    // 这个函数可以有效的避免死锁
    // 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

    // 解锁, 不管锁定了读还是写都可用解锁
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);


    ### 4.2 读写锁使用
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <pthread.h>
    
    // 全局变量
    int number = 0;
    
    // 定义读写锁
    pthread_rwlock_t rwlock;
    
    // 写的线程的处理函数
    void* writeNum(void* arg)
    {
        while(1)
        {
            pthread_rwlock_wrlock(&rwlock);
            int cur = number;
            cur ++;
            number = cur;
            printf("++写操作完毕, number : %d, tid = %ld\n", number, pthread_self());
            pthread_rwlock_unlock(&rwlock);
            // 添加sleep目的是要看到多个线程交替工作
            usleep(rand() % 100);
        }
    
        return NULL;
    }
    
    // 读线程的处理函数
    // 多个线程可以如果处理动作相同, 可以使用相同的处理函数
    // 每个线程中的栈资源是独享
    void* readNum(void* arg)
    {
        while(1)
        {
            pthread_rwlock_rdlock(&rwlock);
            printf("--全局变量number = %d, tid = %ld\n", number, pthread_self());
            pthread_rwlock_unlock(&rwlock);
            usleep(rand() % 100);
        }
        return NULL;
    }
    
    int main()
    {
        // 初始化读写锁
        pthread_rwlock_init(&rwlock, NULL);
    
        // 3个写线程, 5个读的线程
        pthread_t wtid[3];
        pthread_t rtid[5];
        for(int i=0; i<3; ++i)
        {
            pthread_create(&wtid[i], NULL, writeNum, NULL);
        }
    
        for(int i=0; i<5; ++i)
        {
            pthread_create(&rtid[i], NULL, readNum, NULL);
        }
    
        // 释放资源
        for(int i=0; i<3; ++i)
        {
            pthread_join(wtid[i], NULL);
        }
    
        for(int i=0; i<5; ++i)
        {
            pthread_join(rtid[i], NULL);
        }
    
        // 销毁读写锁
        pthread_rwlock_destroy(&rwlock);
    
        return 0;
    }

## 5. 条件变量概述
条件变量是用来等待线程而不是上锁的，条件变量通常和互斥锁一起使用。条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用。  

- 即使拿到互斥锁后也要满足条件才能执行；
- 其他线程可以唤醒被阻塞的线程；

为什么条件变量的阻塞要写在临界区
pthread_cond_wait（）在阻塞线程的同时会打开已获得的互斥锁。
进入临界区后再进行判断，保证判断的正确性，防止在判断之后，加锁成功之前，判断表达式的值再被其他线程修改。

### 5.1 条件变量函数

严格意义上来说，条件变量的主要作用不是处理线程同步, 而是进行线程的阻塞。如果在多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：

- 假设有A-Z 26个线程，这26个线程共同访问同一把互斥锁，如果线程A加锁成功，那么其余B-Z线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区  
- 条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱  
一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为pthread_cond_t，这样就可以定义一个条件变量类型的变量了：  
`pthread_cond_t cond;`    

被条件变量阻塞的线程的线程信息会被**记录**到这个变量中，以便在解除阻塞的时候使用。

>条件变量操作函数函数原型如下：

    #include <pthread.h>
    pthread_cond_t cond;
    // 初始化
    int pthread_cond_init(pthread_cond_t *restrict cond,
          const pthread_condattr_t *restrict attr);
    // 销毁释放资源        
    int pthread_cond_destroy(pthread_cond_t *cond);
- 参数:
    - cond: 条件变量的地址
    - attr: 条件变量属性, 一般使用默认属性, 指定为NULL


    // 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞
    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);

通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个**互斥锁主要功能是进行线程同步**，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：
  
- 在阻塞线程时候，如果线程已经对互斥锁mutex上锁，那么会将这把锁打开，这样做是为了避免死锁
- 当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个mutex互斥锁锁上，继续向下访问临界区

    // 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示
    struct timespec {
    	time_t tv_sec;  /* Seconds */
    	long   tv_nsec; /* Nanoseconds [0 .. 999999999] */
    };
    // 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了
    int pthread_cond_timedwait(pthread_cond_t *restrict cond,
       pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
    
这个函数的前两个参数和pthread_cond_wait函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：struct timespec这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：

    time_t mytim = time(NULL);	// 1970.1.1 0:0:0 到当前的总秒数
    struct timespec tmsp;
    tmsp.tv_nsec = 0;
    tmsp.tv_sec = time(NULL) + 100;	// 线程阻塞100s


    // 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞
    int pthread_cond_signal(pthread_cond_t *cond);
    // 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞
    int pthread_cond_broadcast(pthread_cond_t *cond);
    
调用上面两个函数中的任意一个，都可以唤醒被pthread_cond_wait或者pthread_cond_timedwait阻塞的线程，区别就在于pthread_cond_signal是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast是唤醒所有被阻塞的线程。


## 6. 信号量

## 6.1 信号量函数
信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。

信号量（信号灯）与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程, 不能完全保证线程安全，如果要保证线程安全, 需要信号量和互斥锁一起使用。

信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为sem_t对应的头文件为<semaphore.h>：

    #include <semaphore.h>
    sem_t sem;
    
>Linux提供的信号量操作函数原型如下：

    #include <semaphore.h>
    // 初始化信号量/信号灯
    int sem_init(sem_t *sem, int pshared, unsigned int value);
    // 资源释放, 线程销毁之后调用这个函数即可
    // 参数 sem 就是 sem_init() 的第一个参数            
    int sem_destroy(sem_t *sem);

* 参数:
    * sem：信号量变量地址
    * pshared：
        * 0：线程同步
        * 非0：进程同步
    * value：初始化当前信号量拥有的资源数（>=0），如果资源数为0，线程就会被阻塞了。

    // 参数 sem 就是 sem_init() 的第一个参数  
    // 函数被调用sem中的资源就会被消耗1个, 资源数-1
    int sem_wait(sem_t *sem);

当线程调用这个函数，并且sem中的资源数>0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到sem中的资源数减为0时，资源被耗尽，因此线程也就被阻塞了。

    // 参数 sem 就是 sem_init() 的第一个参数  
    // 函数被调用sem中的资源就会被消耗1个, 资源数-1
    int sem_trywait(sem_t *sem);

当线程调用这个函数，并且sem中的资源数>0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到sem中的资源数减为0时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。

    // 调用该函数给sem中的资源数+1
    int sem_post(sem_t *sem);

调用该函数会将sem中的资源数+1，如果有线程在调用sem_wait、sem_trywait、sem_timedwait时因为sem中的资源数为0被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。

    // 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中
    // sval是一个传出参数
    int sem_getvalue(sem_t *sem, int *sval);

通过这个函数可以查看sem中现在拥有的资源个数，通过第二个参数sval将数据传出，也就是说第二个参数的作用和返回值是一样的。

## 个人对于条件变量与信号量的理解：
<font color = green>
**条件变量需要结合实际的判断条件进行阻塞，比如任务队列为空或者认为队列已满，阻塞位置是在锁内，（因为判断条件通常也是共享内存，保证内存的一直性）一般结合while循环，在阻塞之后会将锁打开，多个线程会同时阻塞在条件变量阻塞函数上。哪个线程拿到锁再进行while条件判断。这样就保证：不管是从上到下的判断while，还是从循环内部判断while，都是在加锁之后的。**

         pthread_mutex_lock(&mutex);
        // 一直消费, 删除链表中的一个节点
        while (head == NULL)   // 条件判断
        {
            pthread_cond_wait(&cond, &mutex);
        }



**而信号量一般写在锁外，因为它的阻塞不会将锁解开。如果写在锁内，容易造成在锁内阻塞，其他线程拿不到锁，无法更改信号量，导致死锁。正因为信号量是一个原子操作，所以它可以作为一个共享内存写在锁外。它只起到一个线程自动放行的作用，线程能不能继续执行下去，还要看它能不能拿到下面的锁。**
</font>

    // 生产者拿一个信号灯
    sem_wait(&psem);
    // 创建一个链表的新节点
    struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
    // 创建一个链表的新节点
    struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));  
    pthread_mutex_unlock(&mutex);

    // 通知消费者消费
    sem_post(&csem);

</font>