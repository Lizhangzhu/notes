<font face="微软雅黑" size = 3 >
<style>
body{
line-height:3em;
}
</style>

# 线程池
## 线程池的原理
我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：

1. 任务队列，存储需要处理的任务，由工作的线程来处理这些任务
    * 通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
    * 已处理的任务会被从任务队列中删除
    * 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程
1. 工作的线程（任务队列任务的消费者） ，N个
    * 线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理
    * 工作的线程相当于是任务队列的消费者角色，
    * 如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量/信号量阻塞)
    * 如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作
  
1. 管理者线程（不处理任务队列中的任务）
    * 1个它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
    * 当任务过多的时候, 可以适当的创建一些新的工作线程
    * 当任务过少的时候, 可以适当的销毁一些工作的线程


管理者线程只有一个，经过sleep定时销毁与添加线程，工作的线程有多个，两者分开存储；
任务队列可以是一个数组，链表，C++的容器，可以使用数组实现循环队列。任务队列也是一个复合结构，存储函数的指针与参数。
线程池是一个共享资源，需要有锁保护，而busynum是变化频率很高，所以需要单独加一把锁效率更高。
在空闲线程比较多的时候要杀死线程，在空闲线程比较少的时候创建线程。


##  任务队列
    // 任务结构体
    typedef struct Task
    {
        void (*function)(void* arg);
        void* arg;
    }Task;

## 线程池定义

    // 线程池结构体
    struct ThreadPool
    {
        // 任务队列
        Task* taskQ;
        int queueCapacity;  // 容量
        int queueSize;      // 当前任务个数
        int queueFront;     // 队头 -> 取数据
        int queueRear;      // 队尾 -> 放数据
    
        pthread_t managerID;    // 管理者线程ID
        pthread_t *threadIDs;   // 工作的线程ID
        int minNum;             // 最小线程数量
        int maxNum;             // 最大线程数量
        int busyNum;            // 忙的线程的个数
        int liveNum;            // 存活的线程的个数
        int exitNum;            // 要销毁的线程个数
        pthread_mutex_t mutexPool;  // 锁整个的线程池
        pthread_mutex_t mutexBusy;  // 锁busyNum变量
        pthread_cond_t notFull;     // 任务队列是不是满了
        pthread_cond_t notEmpty;    // 任务队列是不是空了
    
        int shutdown;           // 是不是要销毁线程池, 销毁为1, 不销毁为0
    };
